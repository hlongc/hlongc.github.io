[{"title":"双向链表实现LRU算法","date":"2022-01-05T14:42:31.000Z","path":"2022/01/05/lru/","text":"LRULRU是Least Recently Used的缩写，即最近最少使用，算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 特点- 新数据插入到链表头部 - 每当缓存命中（即缓存数据被访问），则将数据移到链表头部 - 当链表满的时候，将链表尾部的数据丢弃 缺点- 命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部，时间复杂度较高 应用场景vue中的keep-alive组件就用到了该思想，该组件是一个抽象组件，对包裹的组件进行缓存，避免了常用组件频繁的创建和销毁，该组件有个属性max，用来设置缓存的最大数量，当组件A被激活时会触发该组件的activated钩子函数，当切换到其他组件时，A组件的deactivated钩子函数会被触发。 用双向链表实现LRU用双向链表+map缓存的方式实现LRU可以做到时间复杂度为O(1)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class ListNode &#123; constructor(key, value) &#123; this.key = key; this.value = value; this.next = null; this.prev = null; &#125;&#125;class LRUCache &#123; constructor(capacity) &#123; this.capacity = capacity; // 链表最大长度 this.size = 0; // 当前长度 this.cache = new Map(); // 映射表 this.dummyHead = new ListNode(); // 虚拟头结点 this.dummyTail = new ListNode(); // 虚拟尾结点 this.dummyHead.next = this.dummyTail; // 后继节点 this.dummyTail.prev = this.dummyHead; // 前驱节点 &#125; get(key) &#123; // 时间复杂度O(1) if (!this.cache.has(key)) &#123; return -1; &#125; const node = this.cache.get(key); this.moveToHead(node); return node.value; &#125; put(key, value) &#123; if (this.cache.has(key)) &#123; // 已存在就更新节点值，并且移动到头结点 const node = this.cache.get(key); node.value = value; this.moveToHead(node); &#125; else &#123; // 不存在就新建节点，也放到头结点 const node = new ListNode(key, value); this.size++; if (this.size &gt; this.capacity) &#123; this.removeTail(); &#125; this.addToHead(node); this.cache.set(key, node); &#125; &#125; removeTail() &#123; // 移除尾结点 const tail = this.dummyTail.prev; this.removeNodeFromList(tail); this.size--; return tail; &#125; moveToHead(node) &#123; this.removeNodeFromList(node); this.addToHead(node); &#125; removeNodeFromList(node) &#123; const prev = node.prev; const next = node.next; prev.next = next; next.prev = prev; this.cache.delete(node.key); &#125; addToHead(node) &#123; const oldHead = this.dummyHead.next; this.dummyHead.next = node; node.prev = this.dummyHead; node.next = oldHead; oldHead.prev = node; this.cache.set(node.key, node); &#125;&#125;const lRUCache = new LRUCache(2);lRUCache.put(\"a\", 1); // 缓存是 &#123;a=1&#125;lRUCache.put(\"a\", 2); // 缓存是 &#123;a=2&#125;console.log(lRUCache.get(\"a\")); // 返回 2lRUCache.put(\"b\", 1); // 缓存是 &#123;b=1, a=2&#125;lRUCache.put(\"c\", 1); // &#123; c=1, b=1 &#125;console.log(lRUCache.get(\"a\")); // 返回 -1 (未找到)console.log(lRUCache.dummyHead);&#123; /* &lt;ref *2&gt; ListNode &#123; key: undefined, value: undefined, next: &lt;ref *1&gt; ListNode &#123; key: 'c', value: 1, next: ListNode &#123; key: 'b', value: 1, next: [ListNode], prev: [Circular *1] &#125;, prev: [Circular *2] &#125;, prev: null&#125; */&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/hlongc/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://github.com/hlongc/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Hello World","date":"2022-01-04T13:36:15.553Z","path":"2022/01/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"三数之和","date":"2021-09-01T15:07:01.000Z","path":"2021/09/01/3sum/","text":"原题链接 题目描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1：输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 示例 2：输入：nums = []输出：[] 示例 3：输入：nums = [0]输出：[] 题目分析需要在数组中找到三个元素和为0的组合，并且是不重复的三元组，如果不存在则返回空数组，那我们可以对数组进行升序，升序有两个好处: 方便跳过重复元素(因为寻找的是不重复的三元组)，因为相同的元素都是贴在一起的 当正在遍历的元素大于0时，那就可以停止遍历了，说明后续的元素都是大于0，已经不符合题意 在排序完成以后，依次遍历每个元素，假设当前遍历元素为nums[i]，那需要在剩下的右侧元素中找出其余两个元素，对此可以使用双指针进行遍历left = i + 1, right = length - 1，判断num[i] + nums[left] + nums[right] = 0是否满足，如果满足则找到一组，然后根据情况移动双指针。 代码实现1234567891011121314151617181920212223242526272829/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function(nums) &#123; nums.sort((a, b) =&gt; a - b) // 进行升序，方便跳过重复元素 const ret = [], len = nums.length for (let i = 0; i &lt; len - 2; i++) &#123; if (nums[i] &gt; 0) break // 当前元素已经大于0，不满足条件 // 跳过重复元素,可以避免这种情况发生[-1, -1, 0, 1],如果不跳过第二次的-1，那么会有两个重复的结果[[-1, 0, 1], [-1, 0, 1]]不满足题意 if (nums[i] === nums[i - 1]) continue const target = -nums[i] let left = i + 1, right = len - 1 while(left &lt; right) &#123; const sum = nums[left] + nums[right] if (sum === target) &#123; ret.push([nums[i], nums[left], nums[right]]) while(left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++ // 跳过相同元素，避免结果重复，下面同理 while(left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right-- left++ right-- &#125; else &#123; // 当前值大于目标值说明过大，移动右指针，反之移动左指针 sum &gt; target ? right-- : left++ &#125; &#125; &#125; return ret&#125;;","tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/hlongc/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://github.com/hlongc/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"git撤回已提交到远程的commit信息","date":"2021-08-31T05:55:24.000Z","path":"2021/08/31/git-reset/","text":"场景：不小心把本地调试的代码推送到了远程，现在需要撤回本次commit(红色框) 查看提交的日志信息123git reflogeab78c1 (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: feat: add foo.txt2ea574d HEAD@&#123;1&#125;: commit (initial): feat: add readme.md 可以看到eab78c1就是我们要撤回的版本信 通过hash值在本地进行回退通过git reset命令进行回退，该命令后面可以跟参数 参数 含义 –soft 不删除工作空间的改动代码 ，撤销commit，不撤销git add file –hard 删除工作空间的改动代码，撤销commit且撤销add 由于我不再需要调试的代码，直接使用--hard选项，并且跟上撤回到指定版本的hash值 12git reset --hard 2ea574dHEAD is now at 2ea574d feat: add readme.md 撤回成功以后，再通过git log查看当前的提交日志，可以看到已经回到了第一次提交的状态 123456git logcommit 2ea574df7af093c927adcdb1a98151e8b8a5ff7f (HEAD -&gt; master)Author: Date: Tue Aug 31 15:04:55 2021 +0800 feat: add readme.md 把撤回以后的结果推送到远程如果通过git push origin master推送到远程仓库，会出现报错，因为远程仓库和本地版本不一致 此时可以通过参数--force进行强制覆盖 最后查看远程仓库的commit信息，可以看到已经回退成功。","tags":[{"name":"git","slug":"git","permalink":"https://github.com/hlongc/tags/git/"}]}]